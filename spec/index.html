<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>RDF 1.2 Interoperability</title>
  <script src="https://www.w3.org/Tools/respec/respec-w3c" class="remove"></script>
  <script src="./common/local-biblio.js" class="remove"></script>
  <script src="./common/fixup.js" class="remove"></script>
  <script class='remove'>
    // See https://github.com/w3c/respec/wiki/ for how to configure ReSpec
    var respecConfig = {
      specStatus: "ED",
      group: "wg/rdf-star",
      github: "https://github.com/w3c/rdf-interop/",
      edDraftURI: "https://w3c.github.io/rdf-interop/spec/",
      shortName: "rdf12-interop",
      editors: [{
        name: "Pierre-Antoine Champin",
        w3cid: "129656"
      }],
      localBiblio: localBibliography,
    };
  </script>
</head>
<body>

<section id="abstract">
  <p>
    The goal of this specification is to provide guidance and good practices to achieve interoperability across different versions or profiles of RDF.
  </p>
</section>
<section id="sotd">
  <section id="related" data-include="./common/related.html"></section>
</section>

<section id="introduction">
  <h2>Introduction</h2>

  <p>
    RDF 1.2 refines and extends the RDF data model that was introduced in RDF 1.1, most notably
    by adding <a data-cite="RDF12-CONCEPTS#section-triple-terms">triple terms</a> for
    representing statements about statements directly in RDF graphs [[RDF12-CONCEPTS]].
    As a consequence, the RDF 1.2 family of specifications distinguishes between
    RDF [=Basic=] and RDF [=Full=] conformance classes, reflecting differences in the
    features that implementations support, and in the kinds of graphs and datasets
    they are able to consume and produce.
  </p>

  <p>
    Importantly, the RDF ecosystem already includes a large body of deployed data,
    tools, and vocabularies based on RDF 1.1 and its earlier specifications. Some
    systems will be updated to support RDF 1.2 [=Full=] features such as triple terms,
    while others will remain limited to RDF [=Basic=] (for example, because they only
    implement a subset of the abstract data model, or because they are constrained by
    existing APIs, storage backends, or query languages). Data may also be constrained
    by profiles that restrict which RDF features are allowed in a given context.
    Ensuring that these heterogeneous components can interoperate in a predictable way
    is essential for the continued growth of the RDF ecosystem.
  </p>

  <p>
    Therefore, one goal of this specification is to provide guidance and good practices
    to achieve interoperability across different versions and profiles of RDF.
    It focuses on describing how RDF [=Full=] graphs and datasets that make use of
    triple terms can be transformed into RDF [=Basic=] graphs and datasets, and how the
    original [=Full=] data can be reconstructed when appropriate. These transformations
    allow data producers to publish RDF that is consumable by RDF [=Basic=] tools,
    while preserving enough information for RDF [=Full=] tools to recover the original
    structure when needed.
  </p>

  <p>
    In particular, this document:
  </p>

  <ul>
    <li>
      defines <em>basic encoding</em>, a transformation from RDF [=Full=] graphs and
      datasets to RDF [=Basic=] graphs and datasets that replaces [=triple terms=]
      with [=blank nodes=] and associated structural triples;
    </li>
    <li>
      defines the corresponding <em>basic decoding</em> transformation that recovers
      triple terms from graphs and datasets that were previously [=basic encoded=];
    </li>
    <li>
      discusses limitations and caveats of these transformations, in particular with
      respect to graphs that already use the vocabulary reserved for basic encoding,
      or that are constructed by merging encoded and non-encoded data;
    </li>
    <li>
      provides guidance for implementers and profile authors on how to use these
      transformations in order to improve interoperability between RDF [=Basic=] and
      RDF [=Full=] systems, and between RDF 1.1 and RDF 1.2 deployments.
    </li>
  </ul>

  <p>
    The transformations defined here are designed to be information-preserving,
    idempotent, and (subject to the limitations described in this document)
    applicable to any RDF [=Full=] graph or dataset. They do <em>not</em> aim to
    preserve the precise entailment relationships described in [[RDF12-SEMANTICS]]:
    the encoded graphs are not, in general, semantically [=equivalent=] to the
    originals under all entailment regimes. Instead, the focus is on faithful
    round-tripping of data structures so that information is not lost when moving
    between implementations with different feature support.
  </p>

</section>

<section id="notation">
  <h2>Notation and Terminology</h2>

  <p>This document uses the following terminology for describing RDF graph syntax, all as defined in the companion RDF Concepts specification [[RDF12-CONCEPTS]]:
    <dfn data-cite="RDF12-CONCEPTS#dfn-appear" data-lt="appearing">appear</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-asserted-triple">asserted triple</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-basic">basic</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-blank-node">blank node</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-default-graph">default graph</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-equivalence">equivalent</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-full">full</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-named-graph">named graph</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-object">object</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-predicate">predicate</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-dataset">RDF dataset</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-rdf-graph">RDF graph</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-reifier">reifier</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-subject">subject</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-triple">triple</dfn>,
    <dfn data-cite="RDF12-CONCEPTS#dfn-triple term">triple term</dfn>.
</section>

<section id="section-basic-full-interop">
  <h2>Interoperability between RDF [=Basic=] and RDF [=Full=]</h2>

  <p class=issue>Should we make this section normative?</p>

  <p>This section provides transformations between [=Full=] [=RDF graphs=] (respectively, [=RDF datasets=]) and [=Basic=] [=RDF graphs=] (respectively, [=RDF datasets=]),
  to provide some level of interoperability between the different classes of <a data-cite="RDF12-CONCEPTS#conformance">Conformance</a>.

  <p class=issue>Should we go even further and aim to provide interoperability between <em>RDF 1.1</em> and RDF 1.2 [=Full=]?</p>

  <p class=issue>AT RISK: The Working Group may decide to replace the terms `rdf:TripleTerm`, `rdf:ttSubject`, `rdf:ttPredicate`, and `rdf:ttObject` used in this section with other terms, possibly in a different namespace.</p>

  <p>These transformation are designed to be:</p>

  <dl>
    <dt>Information preserving</dt>
    <dd>It must be possible to reconstruct the input graph (respectively, dataset) from the output graph (respectively, dataset).
      Note, however, that these transformations are not designed to preserve semantics:
      the output graph is not semantically [=equivalent=] to the input graph,
      at least not in the entailment regimes defined in [[RDF12-SEMANTICS]].
    </dd>
    <dt>Idempotent</dt>
    <dd>Applying a transformation several times to a graph (respectively, dataset) should have the same effect as applying it once.
      Moreover, [=basic encoding=] a graph (respectively, dataset) that is already complying with RDF [=Basic=] (i.e., containing no [=triple term=]) must result in the same graph (respectively, dataset).
    </dd>
    <dt>Universal</dt>
    <dd>It should be possible to transform any [=Full=] graph (respectively, dataset) to a [=Basic=] graph (respectively, dataset) using this method.
      There is actually <a href="#section-basicenc-caveat">a minor caveat</a> to this property.
    </dd>
  </dl>

  <section id="section-basicenc-definition">
    <h2>From [=Full=] to [=Basic=]</h2>

    <p>
      Encoding an [=RDF graph=] to ensure that it is consumable by an RDF [=Basic=] implementation is called <dfn data-lt="basic encode|basic encoded">basic encoding</dfn> it.
      [=Basic encoding=] consists of repeating the following steps until no [=triple term=] [=appears=] in the graph, and the graph is therefore compliant with RDF [=Basic=]: picking a [=triple term=] <var>tt</var> that [=appears=] in the graph; minting a fresh [=blank node=] <var>b</var>
      (i.e., a blank node not yet in use in the graph); replacing all occurrences of <var>tt</var> [=appearing=] in the graph with <var>b</var>;
      and then adding the following [=triples=] to the graph (where <var>s</var>, <var>p</var>, and <var>o</var> are respectively the [=subject=], [=predicate=] and [=object=] of <var>tt</var>):
    </p>
    <ul>
      <li>(<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      <li>(<var>b</var>, `rdf:ttSubject`, <var>s</var>)
      <li>(<var>b</var>, `rdf:ttPredicate`, <var>p</var>)
      <li>(<var>b</var>, `rdf:ttObject`, <var>o</var>)
    </ul>

    <p>Note that this transformation is <em>information preserving</em> only when the input graph either has no [=triple term=] [=appearing=] in it,
      or contains no [=asserted triple=] (<var>b</var>, `rdf:type`, `rdf:TripleTerm`) where <var>b</var> is a [=blank node=].
      Implementations encountering this situation ought to report an error.
      This limitation is discussed in Section <a href="#section-basicenc-caveat"></a>.
    </p>

    <p class=note>The blank nodes generated to replace [=triple terms=] should not be confused with the [=reifiers=] that are typically associated with these [=triple terms=].</p>

    <p>
      [=Basic encoding=] an [=RDF dataset=] consists of [=basic encoding=] its [=default graph=] and each of its [=named graph=].
      In this case, the fresh [=blank node=] assigned to each [=triple term=] must not be used in any graph of the dataset.
    </p>

    <p>
      A detailed algorithm of the transformation is found in Section <a href="#section-basicenc-algo"></a>.
    </p>

    <section id="section-basicenc-example">
      <h2>Example</h2>

      <p>The examples in this section are expressed in the Turtle concrete syntax [[RDF12-TURTLE]].</p>

      <pre id="ex-basicenc-input"
       class="example nohighlight"
       title="An input Full RDF graph"
       data-include="./ex-basicenc-input.ttl"
       data-include-format="text"
      ></pre>

      <pre id="ex-basicenc-input2"
       class="example nohighlight"
       title="The same graph as above, with reifiers made explicit"
       data-include="./ex-basicenc-input2.ttl"
       data-include-format="text"
      ></pre>

      <pre id="ex-basicenc-output"
       class="example nohighlight"
       title="The result of basic encoding the dataset above"
       data-include="./ex-basicenc-output.ttl"
       data-include-format="text"
      ></pre>

    </section>

  </section>

  <section id="section-basicdec-definition">
    <h2>From [=Basic=] to [=Full=]</h2>

    <p>Reverting a [=basic encoded=] graph to its original form consists of locating
      each [=asserted triple=] (<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      that has a [=blank node=] <var>b</var> as its subject,
      along with the three associated [=asserted triples=]
      that have the same [=blank node=] <var>b</var> as their subjects, i.e.,
      (<var>b</var>, `rdf:ttSubject`, <var>s</var>),
      (<var>b</var>, `rdf:ttPredicate`, <var>p</var>),
      and (<var>b</var>, `rdf:ttObject`, <var>o</var>);
      removing these four [=triples=] from the graph;
      and replacing all remaining occurrences of <var>b</var> [=appearing=] in the graph
      with the [=triple term=] (<var>s</var>, <var>p</var>, <var>o</var>).
    </p>

    <p>An implementation ought to report an error if, for a given <var>b</var>,
      it can not unambiguously determine <var>s</var>, <var>p</var>, or <var>o</var>
      (i.e., if one of the properties of <var>b</var>
      — `rdf:ttSubject`, `rdf:ttPredicate`, or `rdf:ttObject` —
      is missing or duplicated).
      An implementation also ought to report an error if the input graph contains
      at the same time a [=triple term=] and an [=asserted triple=]
      (<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      where <var>b</var> is the same [=blank node=].
      Note that none of these situations can occur if the input graph was produced by the [=basic encoding=] transformation.
    </p>

    <p>To revert a [=basic encoded=] [=RDF dataset=] to its original form, the transformation above is applied to its [=default graph=] and to each of its [=named graphs=].
    </p>

    <p>Note that this transformation has no effect on any [=RDF graph=] or [=RDF dataset=] that does not use the `rdf:TripleTerm` type,
      including [=Full=] graphs or datasets containing [=triple terms=].
      This makes this transformation <em>idempotent</em> as intended.
    </p>
  </section>

  <section id="section-basicenc-caveat">
    <h2>Limitations</h2>

    <p>The two transformations above explicitly do not support graphs or datasets containing at the same time a [=triple term=] and an [=asserted triple=]
      (<var>b</var>, `rdf:type`, `rdf:TripleTerm`)
      where <var>b</var> is a [=blank node=].
      This means that the [=basic encoding=] transformation is not <em>strictly</em> universal.
    </p>

    <p>This limitation should not be an issue in practice.
      The `rdf:TripleTerm` type is unlikely to be in used in any published graph or dataset,
      as it was not defined prior to this specification.
      For this reason, using it would actually have been bad practice.
      For future graphs and datasets, this type should be considered to be reserved for use within the [=basic encoding=] transformation, and not used otherwise.
    </p>

    <p class=note>
      This is one reason why this transformation introduces new vocabulary terms
      (`rdf:TripleTerm`, `rdf:ttSubject`, `rdf:ttPredicate`, `rdf::ttObject`),
      rather than repurposing the existing <a data-cite="RDF12-SCHEMA#ch_reificationvocab">reification vocabulary</a>
      (`rdf:Statement`, `rdf:subject`, `rdf:predicate`, `rdf:object`).
      Unlike `rdf:TripleTerm`, `rdf:Statement` is known to be found in
      widely used datasets (e.g., <a href="https://www.uniprot.org/">Uniprot</a>),
      so reserving its use for the [=basic encoding=] transformation was not an option.
    </p>

    <p>Another consequence of this restriction is that implementers will need to be aware and careful when merging graphs in an application that [=basic encoded=] graphs or datasets.
      The concern is that merging a [=Full=] [=RDF graph=] containing at least one [=triple term=]
      with a [=basic encoded=] [=RDF graph=] (which might contain [=blank node=] instances of `rdf:TripleTerm`)
      could result in a "hybrid" graph that cannot be transformed to a consistent [=Full=] nor [=Basic=] [=RDF graph=].
      Therefore, such applications should [=basic encode=] every graph prior to merging them.
      Conversely, applications supporting RDF [=Full=] should make sure to apply the reverse transformation
      to any graph that is known or likely to have been [=basic encoded=],
      to avoid creating such "hybrid" graphs.
      Since these transformations are designed to be <em>idempotent</em>, there is no harm in applying them more than necessary.
    </p>
  </section>

  <section>
    <h2>Algorithms</h2>

    <section id="section-basicenc-algo" class="algorithm">
      <h2>The `basic-encode` algorithm</h2>

      <p>The algorithm expects one input variable <var>Gᵢ</var> which is an [=RDF graph=]. It returns a [=Basic=] [=RDF graph=].
      </p>

      <ol>
        <li>Let <var>Gₒ</var> be an empty [=RDF graph=].</li>
        <li>Let <var>M</var> be an empty map from [=triple terms=] to [=blank nodes=].</li>
        <li>Let <var>inputKind</var> be `null`.</li>
        <li>For each [=triple=] (<var>s</var>, <var>p</var>, <var>o</var>) in <var>Gᵢ</var>:<ol>
          <li>If <var>s</var> is a [=blank node=], <var>p</var> is `rdf:type` and <var>o</var> is `rdf:TripleTerm`, then:<ol>
            <li id="basicenc-error1">If <var>inputKind</var> is `"full"` then exit with an error.</li>
            <li>Otherwise, set <var>inputKind</var> to `"basic"`.</li>
          </ol></li>
          <li>If <var>o</var> is a [=triple term=], then:<ol>
            <li id="basicenc-error2">If <var>inputKind</var> is `"basic"` then exit with an error.</li>
            <li>Otherwise, set <var>inputKind</var> to `"full"`.</li>
            <li>Let <var>b</var>, <var>M'</var> and <var>G'</var> be the result of invoking <a href="#section-ctt-algo">`basic-encode-triple-term`</a> passing <var>o</var> as <var>t</var> and <var>M</var> as <var>Mi</var>.</li>
            <li>Merge <var>M'</var> into <var>M</var>.
            <li>Merge <var>G'</var> into <var>Gₒ</var>.
            <li>Set <var>o</var> to <var>b</var>.
          </ol></li>
          <li>Add the [=triple=] (<var>s</var>, <var>p</var>, <var>o</var>) to <var>Gₒ</var>.</li>
        </ol></li>
        <li>Return <var>Gₒ</var>.</li>
      </ol>
    </section>

    <section id="section-ctt-algo" class="algorithm">
      <h2>The `basic-encode-triple-term` algorithm</h2>

      <p>This algorithm is responsible for incrementally populating the mapping <var>M</var> and the graph <var>G</var> used internally by the <a href="#section-basicenc-algo">`basic-encode`</a> algorithm. It receives a [=triple term=] as input and processes it recursively (in case its object is itself a [=triple term=]). It returns, among other things, the [=blank node=] minted to replace the [=triple term=] in the transformed [=Basic=] [=RDF graph=].</p>

      <p>This algorithm expects two input variables:
        a [=triple term=] <var>t</var>,
        and a map <var>Mᵢ</var> from [=triple terms=] to [=blank nodes=].
        It returns a [=blank node=] <var>b</var>,
        a map <var>Mₒ</var> from [=triple terms=] to [=blank nodes=],
        and a [=Basic=] [=RDF graph=] <var>G</var>.
      </p>

      <ol>
        <li>Let <var>Mₒ</var> be an empty map.</li>
        <li>Let <var>G</var> be an empty [=RDF graph=].</li>
        <li>Let <var>b</var> be the [=blank node=] associated with <var>t</var> in <var>Mᵢ</var>, if any.
        <li>Otherwise:<ol>
          <li>Let <var>s</var>, <var>p</var> and <var>o</var> be the subject, predicate and object of <var>t</var>, respectively.</li>
          <li>If <var>o</var> is a [=triple term=], then:<ol>
            <li>Let <var>b'</var>, <var>M'</var> and <var>G'</var> be the result of invoking <a href="#section-ctt-algo">`basic-encode-triple-term`</a> passing <var>o</var> as <var>t</var> and <var>Mᵢ</var>.</li>
            <li>Set <var>o</var> to <var>b'</var>.
            <li>Merge <var>M'</var> into <var>Mₒ</var>.
            <li>Merge <var>G'</var> into <var>G</var>.
          </ol></li>
          <li id="qtt-fresh-bnode">Let <var>b</var> be a fresh blank node.</li>
          <li>Add the association (<var>t</var>, <var>b</var>) to <var>Mₒ</var>.</li>
          <li>Add the triples (<var>b</var>, `rdf:type`, `rdf:TripleTerm`), (<var>b</var>, `rdf:ttSubject`, <var>s</var>), (<var>b</var>, `rdf:ttPredicate`, <var>p</var>), and (<var>b</var>, `rdf:ttObject`, <var>o</var>) in <var>G</var>.</li>
        </ol></li>
        <li>Return <var>b</var>, <var>Mₒ</var> and <var>G</var>.</li>
      </ol>

    </section>

    <section id="section-basicdec-algo" class="algorithm">
      <h2>The `basic-decode` algorithm</h2>

      <p class=issue>Write this algorithm</p>
    </section>

  </section>

</section>
<section id="section-Acknowledgments" class="appendix">
  <h2>Acknowledgments</h2>

  <p>In addition to the editors, the following people have contributed to this specification:
    <span id="gh-contributors"></span>
  </p>

  <p data-include="common/participants.html"></p>
</section>

</body>
</html>
